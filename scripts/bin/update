#!/usr/bin/env bash

set -euo pipefail

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

info() { echo -e "${GREEN}[INFO]${NC} $*"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*"; }

usage() {
  cat <<'USAGE'
Usage: update [OPTIONS]

Runs system updates (paru/pacman) plus updates for manually-installed tools.

Options:
  --no-system       Skip paru/pacman update
  --no-codex        Skip updating Codex wrappers in /usr/local/bin
  --no-repos        Skip updating external git repos
  --no-hooks        Skip ~/.config/update.d hooks
  -h, --help        Show help

Environment:
  UPDATE_GITHUB_USER   Your GitHub username (used to skip your own repos)
  UPDATE_REPOS_ROOT    Repo root to scan (default: $PROJECTS_ROOT or ~/Repositories)

Notes:
  - Repo update ignores: clawdbot, opencode, claude-flow
USAGE
}

SKIP_SYSTEM=false
SKIP_CODEX=false
SKIP_REPOS=false
SKIP_HOOKS=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-system) SKIP_SYSTEM=true; shift ;;
    --no-codex) SKIP_CODEX=true; shift ;;
    --no-repos) SKIP_REPOS=true; shift ;;
    --no-hooks) SKIP_HOOKS=true; shift ;;
    -h|--help) usage; exit 0 ;;
    *)
      error "Unknown option: $1"
      usage
      exit 1
      ;;
  esac
done

update_system() {
  if command -v paru >/dev/null 2>&1; then
    info "Updating system packages via paru..."
    paru -Syu --devel --needed
    return 0
  fi

  if command -v pacman >/dev/null 2>&1; then
    info "Updating system packages via pacman..."
    sudo pacman -Syu
    return 0
  fi

  warn "No supported package manager found (expected paru or pacman); skipping system update."
}

ensure_dotslash() {
  if command -v dotslash >/dev/null 2>&1; then
    return 0
  fi

  if command -v pacman >/dev/null 2>&1; then
    info "Installing missing dependency: dotslash"
    sudo pacman -S --needed dotslash
    return 0
  fi

  warn "dotslash not found and pacman unavailable; Codex wrappers may not run."
}

github_latest_download() {
  local repo="$1"
  local asset="$2"
  printf 'https://github.com/%s/releases/latest/download/%s' "$repo" "$asset"
}

install_executable_sudo() {
  local source_path="$1"
  local dest_path="$2"
  sudo install -m 0755 "$source_path" "$dest_path"
}

update_codex_wrappers() (
  if ! command -v curl >/dev/null 2>&1; then
    warn "curl not found; skipping Codex wrapper update."
    return 0
  fi

  ensure_dotslash || true

  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' EXIT

  info "Updating Codex wrappers in /usr/local/bin..."

  local codex_url proxy_url
  codex_url="$(github_latest_download "openai/codex" "codex")"
  proxy_url="$(github_latest_download "openai/codex" "codex-responses-api-proxy")"

  curl -fsSL -o "$tmpdir/codex" "$codex_url"
  curl -fsSL -o "$tmpdir/codex-responses-api-proxy" "$proxy_url"
  chmod 0755 "$tmpdir/codex" "$tmpdir/codex-responses-api-proxy"

  install_executable_sudo "$tmpdir/codex" /usr/local/bin/codex
  install_executable_sudo "$tmpdir/codex-responses-api-proxy" /usr/local/bin/codex-responses-api-proxy

  if command -v codex >/dev/null 2>&1; then
    codex --version || true
  fi
)


get_own_github_user() {
  if [[ -n "${UPDATE_GITHUB_USER:-}" ]]; then
    echo "$UPDATE_GITHUB_USER"
    return 0
  fi

  if ! command -v git >/dev/null 2>&1; then
    return 1
  fi

  local email
  email="$(git config --global --get user.email 2>/dev/null || true)"
  if [[ "$email" =~ ^([0-9]+\+)?([^@]+)@users\.noreply\.github\.com$ ]]; then
    echo "${BASH_REMATCH[2]}"
    return 0
  fi

  return 1
}

parse_github_owner_repo() {
  local url="$1"
  url="${url%.git}"

  if [[ "$url" =~ ^https?://github\.com/([^/]+)/([^/]+)$ ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
    return 0
  fi

  if [[ "$url" =~ ^git@github\.com:([^/]+)/([^/]+)$ ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
    return 0
  fi

  if [[ "$url" =~ ^ssh://git@github\.com/([^/]+)/([^/]+)$ ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
    return 0
  fi

  return 1
}

is_ignored_token() {
  case "$1" in
    clawdbot|opencode|claude-flow) return 0 ;;
    *) return 1 ;;
  esac
}

update_external_repos() {
  if ! command -v git >/dev/null 2>&1; then
    warn "git not found; skipping repo updates."
    return 0
  fi

  local root="${UPDATE_REPOS_ROOT:-${PROJECTS_ROOT:-$HOME/Repositories}}"
  if [[ ! -d "$root" ]]; then
    warn "Repo root not found: $root (set UPDATE_REPOS_ROOT to override); skipping repo updates."
    return 0
  fi

  local own_user
  own_user="$(get_own_github_user 2>/dev/null || true)"

  info "Updating external repos under $root..."
  if [[ -n "$own_user" ]]; then
    info "Skipping repos owned by $own_user"
  else
    warn "Could not determine your GitHub username; set UPDATE_GITHUB_USER to skip your own repos."
  fi

  local fetched=0
  local updated=0
  local up_to_date=0
  local skipped_repo=0
  local skipped_merge=0
  local failed=0

  local dir
  for dir in "$root"/*; do
    [[ -d "$dir" ]] || continue
    [[ -e "$dir/.git" ]] || continue

    local name
    name="$(basename "$dir")"

    if is_ignored_token "$name"; then
      skipped_repo=$((skipped_repo + 1))
      continue
    fi

    local external_remote=""
    local external_url=""
    if external_url="$(git -C "$dir" remote get-url origin 2>/dev/null)"; then
      external_remote="origin"
    elif external_url="$(git -C "$dir" remote get-url upstream 2>/dev/null)"; then
      external_remote="upstream"
    else
      skipped_repo=$((skipped_repo + 1))
      continue
    fi

    local owner_repo
    owner_repo="$(parse_github_owner_repo "$external_url" 2>/dev/null || true)"
    if [[ -n "$owner_repo" ]]; then
      local owner repo
      owner="${owner_repo%% *}"
      repo="${owner_repo#* }"

      if is_ignored_token "$owner" || is_ignored_token "$repo"; then
        skipped_repo=$((skipped_repo + 1))
        continue
      fi

      if [[ -n "$own_user" && "$owner" == "$own_user" ]]; then
        skipped_repo=$((skipped_repo + 1))
        continue
      fi
    fi

    if ! git -C "$dir" fetch --prune --quiet "$external_remote"; then
      warn "Fetch failed: $name"
      failed=$((failed + 1))
      continue
    fi
    fetched=$((fetched + 1))

    if [[ -n "$(git -C "$dir" status --porcelain 2>/dev/null)" ]]; then
      info "Skipping merge: $name (dirty working tree)"
      skipped_merge=$((skipped_merge + 1))
      continue
    fi

    local upstream_ref
    upstream_ref="$(git -C "$dir" rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || true)"
    if [[ -z "$upstream_ref" ]]; then
      info "Skipping merge: $name (no upstream tracking branch)"
      skipped_merge=$((skipped_merge + 1))
      continue
    fi

    local upstream_remote
    upstream_remote="${upstream_ref%%/*}"
    if [[ "$upstream_remote" != "$external_remote" ]]; then
      info "Skipping merge: $name (tracks $upstream_remote, not $external_remote)"
      skipped_merge=$((skipped_merge + 1))
      continue
    fi

    local before after
    before="$(git -C "$dir" rev-parse HEAD 2>/dev/null || true)"
    if git -C "$dir" merge --ff-only --quiet '@{u}'; then
      after="$(git -C "$dir" rev-parse HEAD 2>/dev/null || true)"
      if [[ -n "$before" && -n "$after" && "$before" != "$after" ]]; then
        info "Updated repo: $name"
        updated=$((updated + 1))
      else
        up_to_date=$((up_to_date + 1))
      fi
    else
      warn "Fast-forward failed: $name"
      failed=$((failed + 1))
    fi
  done

  info "Repo updates: fetched=$fetched updated=$updated up_to_date=$up_to_date skipped_repo=$skipped_repo skipped_merge=$skipped_merge failed=$failed"
}

run_update_hooks() {
  local hook_dir="${XDG_CONFIG_HOME:-$HOME/.config}/update.d"
  if [[ ! -d "$hook_dir" ]]; then
    return 0
  fi

  local ran_any=false
  shopt -s nullglob
  for hook in "$hook_dir"/*; do
    if [[ -x "$hook" && -f "$hook" ]]; then
      ran_any=true
      info "Running hook: $(basename "$hook")"
      "$hook"
    fi
  done
  shopt -u nullglob

  if [[ "$ran_any" == false ]]; then
    warn "No executable hooks found in $hook_dir"
  fi
}

if [[ "$SKIP_SYSTEM" == false ]]; then
  update_system
fi

if [[ "$SKIP_CODEX" == false ]]; then
  if ! update_codex_wrappers; then
    warn "Codex wrapper update failed."
  fi
fi

if [[ "$SKIP_REPOS" == false ]]; then
  if ! update_external_repos; then
    warn "Repo updates failed."
  fi
fi

if [[ "$SKIP_HOOKS" == false ]]; then
  if ! run_update_hooks; then
    warn "Update hooks failed."
  fi
fi

info "Update complete."
